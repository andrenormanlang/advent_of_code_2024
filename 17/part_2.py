import sys
import re

def extract_integers(s):
    """
    Extracts all integers (including negative numbers) from a string.

    Args:
        s (str): Input string.

    Returns:
        list of int: List of extracted integers.
    """
    return [int(x) for x in re.findall(r'-?\d+', s)]

def run_program(initial_A, part2, program):
    """
    Simulates the execution of the program with the given initial A value.

    Args:
        initial_A (int): The initial value for Register A.
        part2 (bool): Flag indicating whether to perform Part Two checks.
        program (list of int): The list of program instructions.

    Returns:
        list of int: The list of outputs generated by 'out' instructions.
    """
    # Initialize registers
    A = initial_A
    B = 0
    C = 0
    ip = 0  # Instruction Pointer
    output = []

    while ip < len(program):
        cmd = program[ip]
        if ip + 1 >= len(program):
            break  # No operand available; halt

        op = program[ip + 1]

        # Determine the value of the operand based on its type
        if op in [0, 1, 2, 3]:
            combo = op  # Literal operand
        elif op == 4:
            combo = A
        elif op == 5:
            combo = B
        elif op == 6:
            combo = C
        else:
            combo = -1  # Invalid combo operand

        # Execute instruction based on opcode
        if cmd == 0:
            # adv: A = floor(A / (2^combo))
            if combo < 0:
                break  # Invalid combo operand; halt
            A = A // (2 ** combo)
            ip += 2
        elif cmd == 1:
            # bxl: B = B XOR literal operand
            B ^= op
            ip += 2
        elif cmd == 2:
            # bst: B = (combo % 8)
            B = combo % 8
            ip += 2
        elif cmd == 3:
            # jnz: if A != 0, jump to instruction at index 'op'
            if A != 0:
                if op >= len(program):
                    break  # Jumping beyond program; halt
                ip = op
            else:
                ip += 2
        elif cmd == 4:
            # bxc: B = B XOR C
            B ^= C
            ip += 2
        elif cmd == 5:
            # out: output = (combo % 8)
            out_val = combo % 8
            output.append(out_val)
            if part2:
                # For Part Two, verify if the latest output matches the program's corresponding instruction
                output_len = len(output)
                if output_len > len(program):
                    # Extra outputs, cannot match
                    return output
                expected = program[output_len - 1]
                if out_val != expected:
                    return output
            ip += 2
        elif cmd == 6:
            # bdv: B = floor(A / (2^combo))
            if combo < 0:
                break  # Invalid combo operand; halt
            B = A // (2 ** combo)
            ip += 2
        elif cmd == 7:
            # cdv: C = floor(A / (2^combo))
            if combo < 0:
                break  # Invalid combo operand; halt
            C = A // (2 ** combo)
            ip += 2
        else:
            # Invalid opcode; halt
            break

    return output

def main():
    """
    Main function to execute Part One and Part Two of the puzzle.
    """
    # Determine input file from command-line arguments or default to 'day_17.in'
    infile = sys.argv[1] if len(sys.argv) >= 2 else 'day_17.in'

    # Read and parse the input file
    with open(infile, 'r') as f:
        content = f.read().strip()

    # Split the input into registers and program sections
    regs, program_str = content.split('\n\n')

    # Extract Register A, B, C values
    A, B, C = extract_integers(regs)

    # Extract program instructions
    program = [int(x) for x in program_str.split(':')[1].strip().split(',')]

    # Part One: Run the program with initial A, B=0, C=0 and print the output
    part1_output = run_program(A, False, program)
    print(','.join(map(str, part1_output)))

    # Part Two: Find the lowest positive A that causes the program to output a copy of itself
    Ast = 0
    best = 0
    while True:
        Ast += 1
        # Compute the candidate A value based on Ast
        # Original code uses a specific formula for A
        # 0o676236017 is an octal number; convert to decimal
        A_candidate = Ast * (8 ** 9) + 0o676236017  # 8**9 = 134217728, 0o676236017 = 116997135

        # Run the program with A_candidate, B=0, C=0, and part2=True
        output = run_program(A_candidate, True, program)

        # Check if the output matches the program
        if output == program:
            print(A_candidate)
            break
        elif len(output) > best:
            best = len(output)
            # Optionally, print progress or the best found so far
            # print(f"New best output length: {best} for A = {A_candidate}")

if __name__ == "__main__":
    main()
